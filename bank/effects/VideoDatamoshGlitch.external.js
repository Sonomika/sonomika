// Portable external Video Datamosh Glitch effect (no imports). Uses globals: window.React, window.THREE, window.r3f
const React = globalThis.React; const THREE = globalThis.THREE; const r3f = globalThis.r3f; const { useRef, useMemo } = React || {};

export const metadata = {
  name: 'Video Datamosh Glitch (External)', description: 'Datamosh-style artifacts and variants.', category: 'Video', author: 'VJ System', version: '1.0.0', replacesVideo: true,
  parameters: [ { name: 'intensity', type: 'number', value: 0.3, min: 0.0, max: 1.0, step: 0.05 }, { name: 'frequency', type: 'number', value: 2.0, min: 0.1, max: 10.0, step: 0.1 }, { name: 'glitchType', type: 'select', value: 'datamosh', options:['datamosh','rgb_split','block_shift','scanlines'] }, { name: 'colorShift', type: 'number', value: 0.02, min: 0.0, max: 0.1, step: 0.001 }, { name: 'blockSize', type: 'number', value: 0.1, min: 0.01, max: 0.5, step: 0.01 } ],
};

export default function VideoDatamoshGlitchExternal({ intensity=0.3, frequency=2.0, glitchType='datamosh', colorShift=0.02, blockSize=0.1, videoTexture }){
  if (!React || !THREE || !r3f) return null; const { useFrame } = r3f; const meshRef=useRef(null); const materialRef=useRef(null);
  const vertexShader = `varying vec2 vUv; uniform float time; uniform float intensity; uniform float frequency; uniform float bpm; uniform float blockSize; uniform int glitchType; void main(){ vec2 uv=uv; float beatTime=time*(bpm/60.0); float gTime=time*frequency; float trig=fract(sin(beatTime*3.14159)*43758.5453); float active=step(0.95, trig); if (glitchType==0){ if (active>0.5){ float bX=floor(uv.x/blockSize)*blockSize; float bY=floor(uv.y/blockSize)*blockSize; float oX=sin(gTime*10. + bX*100.)*intensity*.1; float oY=cos(gTime*8. + bY*80.)*intensity*.1; uv.x+=oX; uv.y+=oY; } } else if (glitchType==1){ if (active>0.5){ float sp=sin(gTime*5.)*intensity*.05; uv.x+=sp; } } else if (glitchType==2){ if (active>0.5){ float sX=sin(gTime*3.)*intensity*.2; float sY=cos(gTime*2.)*intensity*.15; uv.x+=sX; uv.y+=sY; } } else { float scan=sin(uv.y*100. + gTime*2.)*intensity*.3; uv.x += scan*.01; } vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`;
  const fragmentShader = `uniform sampler2D tDiffuse; uniform float time; uniform float intensity; uniform float frequency; uniform float bpm; uniform float colorShift; uniform int glitchType; varying vec2 vUv; void main(){ vec2 uv=vUv; float beatTime=time*(bpm/60.0); float gTime=time*frequency; float trig=fract(sin(beatTime*3.14159)*43758.5453); float active=step(0.92, trig); vec4 color=vec4(0.0); if (glitchType==0){ if (active>0.5){ vec4 r=texture2D(tDiffuse, uv + vec2(colorShift*sin(gTime),0.)); vec4 g=texture2D(tDiffuse, uv + vec2(colorShift*cos(gTime*.7),0.)); vec4 b=texture2D(tDiffuse, uv + vec2(colorShift*sin(gTime*1.3),0.)); color=vec4(r.r,g.g,b.b,1.0); float art=sin(uv.x*50. + gTime*10.)*intensity*.5; color.rgb += vec3(art, art*.5, art*.2); } else { color=texture2D(tDiffuse, uv);} } else if (glitchType==1){ if (active>0.5){ float sp=sin(gTime*5.)*intensity*.05; vec4 r=texture2D(tDiffuse, uv + vec2(sp,0.)); vec4 g=texture2D(tDiffuse, uv); vec4 b=texture2D(tDiffuse, uv - vec2(sp,0.)); color=vec4(r.r,g.g,b.b,1.0);} else { color=texture2D(tDiffuse, uv);} } else if (glitchType==2){ if (active>0.5){ float bX=floor(uv.x*20.)/20.; float bY=floor(uv.y*15.)/15.; float sX=sin(gTime*3. + bX*10.)*intensity*.1; float sY=cos(gTime*2. + bY*8.)*intensity*.08; color=texture2D(tDiffuse, uv + vec2(sX,sY)); } else { color=texture2D(tDiffuse, uv);} } else { float scan=sin(uv.y*100. + gTime*2.)*intensity*.3; color=texture2D(tDiffuse, uv); color.rgb *= 1.0 - scan; if (active>0.5){ float art=sin(uv.x*200. + gTime*15.)*intensity*.4; color.rgb += vec3(art, art*.3, art*.1); } } float modI = 1.0 + sin(beatTime*6.28318)*intensity*.2; color.rgb *= modI; gl_FragColor=color; }`;
  const shaderMaterial = useMemo(()=> new THREE.ShaderMaterial({ uniforms:{ time:{value:0}, intensity:{value:intensity}, frequency:{value:frequency}, bpm:{value:(globalThis&&globalThis.VJ_BPM)||120}, colorShift:{value:colorShift}, blockSize:{value:blockSize}, glitchType:{value: glitchType==='datamosh'?0:glitchType==='rgb_split'?1:glitchType==='block_shift'?2:3}, tDiffuse:{value:videoTexture||new THREE.DataTexture(new Uint8Array([0,0,0,255]),1,1,THREE.RGBAFormat)} }, vertexShader, fragmentShader, transparent:true, depthTest:false, depthWrite:false }), [intensity, frequency, glitchType, colorShift, blockSize, videoTexture]);
  useFrame((state)=>{ if (!materialRef.current) materialRef.current=shaderMaterial; if (!materialRef.current) return; materialRef.current.uniforms.time.value = state.clock.elapsedTime; materialRef.current.uniforms.bpm.value = (globalThis&&globalThis.VJ_BPM)||120; });
  const aspect = useMemo(()=>{ if (videoTexture && videoTexture.image){ try { const {width,height}=videoTexture.image; if (width&&height&&width>0&&height>0) return width/height; } catch{} } return 16/9; }, [videoTexture]);
  return React.createElement('mesh',{ref:meshRef, position:[0,0,0.1]}, React.createElement('planeGeometry',{args:[aspect*2,2]}), React.createElement('primitive',{object:shaderMaterial, ref:materialRef}));
}


