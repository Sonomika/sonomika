// sonomika template
const React = globalThis.React; const THREE = globalThis.THREE; const r3f = globalThis.r3f; const { useRef, useMemo, useEffect } = React || {};

export const metadata = {
  name: 'Shader Feedback', description: 'Ping-pong feedback with noise and leaks.', category: 'Effects', author: 'AI', version: '1.0.0', replacesVideo: false,
  parameters: [
    { name: 'feedbackAmount', type: 'number', value: 0.9, min: 0, max: 1, step: 0.01 },
    { name: 'feedbackScale', type: 'number', value: 1.0, min: 0.85, max: 1.2, step: 0.001 },
    { name: 'feedbackRotate', type: 'number', value: 0.0, min: -1.0, max: 1.0, step: 0.01 },
    { name: 'feedbackTranslateX', type: 'number', value: 0.0, min: -0.02, max: 0.02, step: 0.0005 },
    { name: 'feedbackTranslateY', type: 'number', value: 0.0, min: -0.02, max: 0.02, step: 0.0005 },
    { name: 'noiseAmount', type: 'number', value: 0.15, min: 0, max: 1, step: 0.01 },
    { name: 'noiseScale', type: 'number', value: 2.5, min: 0.5, max: 8, step: 0.1 },
    { name: 'lightLeakIntensity', type: 'number', value: 0.3, min: 0, max: 1, step: 0.01 },
    { name: 'lightLeakColor', type: 'color', value: '#ff7e47' },
    { name: 'pulseStrength', type: 'number', value: 0.15, min: 0, max: 1, step: 0.01 },
  ],
};

export default function ShaderFeedback({ feedbackAmount=0.9, feedbackScale=1.0, feedbackRotate=0.0, feedbackTranslateX=0.0, feedbackTranslateY=0.0, noiseAmount=0.15, noiseScale=2.5, lightLeakIntensity=0.3, lightLeakColor='#ff7e47', pulseStrength=0.15, videoTexture, compositionWidth=1920, compositionHeight=1080 }){
  if (!React || !THREE || !r3f) return null; const { useFrame, useThree } = r3f; const { gl } = useThree?.() || { gl: null };
  const outputPlaneRef=useRef(null); const outputMaterialRef=useRef(null); const pingRef=useRef(null); const pongRef=useRef(null); const fbSceneRef=useRef(null); const fbCameraRef=useRef(null); const fbQuadRef=useRef(null); const fbMaterialRef=useRef(null);

  const feedbackMaterial = useMemo(()=>{ const v=`varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0);} `; const f=`precision highp float; varying vec2 vUv; uniform sampler2D uPrevTex; uniform bool uHasPrev; uniform sampler2D uInputTex; uniform bool uHasInput; uniform float uTime; uniform float uBPM; uniform float uFeedbackAmount; uniform float uScale; uniform float uRotate; uniform vec2 uTranslate; uniform float uNoiseAmount; uniform float uNoiseScale; uniform float uLeakIntensity; uniform vec3 uLeakColor; uniform float uPulseStrength; float random(vec2 st){ return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);} float noise(vec2 st){ vec2 i=floor(st); vec2 f=fract(st); float a=random(i); float b=random(i+vec2(1.,0.)); float c=random(i+vec2(0.,1.)); float d=random(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;} float fbm(vec2 st){ float v=0.; float amp=.5; for(int i=0;i<5;i++){ v+=amp*noise(st); st*=2.; amp*=.5;} return v;} vec2 rot(vec2 p,float a){ float s=sin(a), c=cos(a); return mat2(c,-s,s,c)*p; } vec3 leaks(vec2 uv,float time){ vec2 c=vec2(0.5); float dist=distance(uv,c); float radial=1.0-smoothstep(0.0,0.8,dist); float s1=pow(abs(sin((uv.x+uv.y)*10.+time*1.7)),3.); float s2=pow(abs(sin((uv.x-uv.y)*8.+time*1.1)),4.); float m=clamp(radial + .3*s1 + .2*s2,0.0,1.0); return uLeakColor * m * uLeakIntensity; } void main(){ float time=uTime; float pulse=sin(time*(uBPM/60.0)*6.28318)*uPulseStrength; vec2 uv=vUv; vec2 center=vec2(0.5); vec2 duv=uv-center; duv=rot(duv, uRotate*time); duv*=uScale; duv+=uTranslate; vec2 fbUv=center+duv; vec3 prev= uHasPrev ? texture2D(uPrevTex, fbUv).rgb : vec3(0.0); vec3 inputC = uHasInput ? texture2D(uInputTex, uv).rgb : mix(vec3(0.2,0.6,1.0), vec3(1.0,0.3,0.7), fbm(uv*3.+time*.15)); vec2 nUv=uv*uNoiseScale + time*.05; vec2 nOf=vec2(fbm(nUv)-.5, fbm(nUv+vec2(100.,0.))-.5) * uNoiseAmount*(1.0+pulse); vec3 prevN = uHasPrev ? texture2D(uPrevTex, fbUv + nOf).rgb : vec3(0.0); vec3 col = mix(inputC, prevN, clamp(uFeedbackAmount,0.0,1.0)); col += leaks(uv,time); col += (random(uv+time)-.5)*.02; gl_FragColor=vec4(col,1.0);} `; return new THREE.ShaderMaterial({ vertexShader:v, fragmentShader:f, uniforms:{ uPrevTex:{value:null}, uHasPrev:{value:false}, uInputTex:{value:videoTexture||null}, uHasInput:{value:!!videoTexture}, uTime:{value:0}, uBPM:{value:(globalThis&&globalThis.VJ_BPM)||120}, uFeedbackAmount:{value:feedbackAmount}, uScale:{value:feedbackScale}, uRotate:{value:feedbackRotate}, uTranslate:{value:new THREE.Vector2(feedbackTranslateX,feedbackTranslateY)}, uNoiseAmount:{value:noiseAmount}, uNoiseScale:{value:noiseScale}, uLeakIntensity:{value:lightLeakIntensity}, uLeakColor:{value:new THREE.Color(lightLeakColor)}, uPulseStrength:{value:pulseStrength} }, depthTest:false, depthWrite:false }); }, [videoTexture, feedbackAmount, feedbackScale, feedbackRotate, feedbackTranslateX, feedbackTranslateY, noiseAmount, noiseScale, lightLeakIntensity, lightLeakColor, pulseStrength]);

  const outputMaterial = useMemo(()=> new THREE.ShaderMaterial({ vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`, fragmentShader:`precision highp float; varying vec2 vUv; uniform sampler2D uTex; void main(){ gl_FragColor = vec4(texture2D(uTex, vUv).rgb, 1.0); }`, uniforms:{ uTex:{value:null} }, transparent:false }), []);

  useEffect(()=>{ if (!gl) return; const w=Math.max(2, Math.floor(compositionWidth)); const h=Math.max(2, Math.floor(compositionHeight)); const opts={ minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat, type:THREE.UnsignedByteType, depthBuffer:false, stencilBuffer:false }; pingRef.current?.dispose?.(); pongRef.current?.dispose?.(); pingRef.current=new THREE.WebGLRenderTarget(w,h,opts); pongRef.current=new THREE.WebGLRenderTarget(w,h,opts); const fbScene=new THREE.Scene(); const fbCamera=new THREE.OrthographicCamera(-1,1,1,-1,0,1); const quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2), feedbackMaterial); fbScene.add(quad); fbSceneRef.current=fbScene; fbCameraRef.current=fbCamera; fbQuadRef.current=quad; fbMaterialRef.current=feedbackMaterial; gl.setRenderTarget(pingRef.current); gl.clear(true,true,true); gl.setRenderTarget(pongRef.current); gl.clear(true,true,true); gl.setRenderTarget(null); return ()=>{ quad.geometry.dispose(); pingRef.current?.dispose?.(); pongRef.current?.dispose?.(); }; }, [gl, compositionWidth, compositionHeight, feedbackMaterial]);

  useFrame((state)=>{ if (!gl||!pingRef.current||!pongRef.current||!fbSceneRef.current||!fbCameraRef.current||!fbMaterialRef.current) return; fbMaterialRef.current.uniforms.uTime.value = state.clock.elapsedTime; fbMaterialRef.current.uniforms.uBPM.value = (globalThis&&globalThis.VJ_BPM)||120; gl.setRenderTarget(pongRef.current); fbMaterialRef.current.uniforms.uPrevTex.value = pingRef.current.texture; fbMaterialRef.current.uniforms.uHasPrev.value = true; gl.render(fbSceneRef.current, fbCameraRef.current); gl.setRenderTarget(null); const tmp=pingRef.current; pingRef.current=pongRef.current; pongRef.current=tmp; if (outputMaterialRef.current){ outputMaterialRef.current.uniforms.uTex.value = pingRef.current.texture; } });

  return React.createElement('mesh',{ref:outputPlaneRef, position:[0,0,0]}, React.createElement('planeGeometry',{args:[16,9,2,2]}), React.createElement('primitive',{object:outputMaterial, ref:outputMaterialRef}));
}


